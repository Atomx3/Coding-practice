手牌评估
---------------
这个项目的另一部分是编写一些代码来评估和比较手牌。请记住，在第二课程中，你已经为这些代码编写了测试用例。这意味着你已经考虑了可能出现的各种特殊情况，并且在你完成代码时，将有一套完整的测试用例准备就绪。

你在这一步的最终目标是编写一个函数，当传递两副手牌时，可以确定哪一副赢了（或者它们是否打成了平手）。我们将使用你在前一部分中使用的 `deck_t` 类型来表示一副手牌（一副手牌只是一副更小的牌——它们都只是一组牌）。

确定谁赢了有三个主要步骤：
  (1) 弄清楚每副手牌的排名（顺子、同花等）。如果你查看 `cards.h`，你会看到 `enum hand_ranking_t`，你在第二课程中已经使用过了。
  (2) 弄清楚哪5张牌组成了手牌（挑选出构成同花的5张牌，或者两对和一个决胜牌）。
  (3) 比较排名，如果它们相同，通过比较手牌中的牌值来打破平手。

在这一点上，你可能会认为有很多代码需要编写，因为有所有不同可能的牌的组合和不同可能的手牌排名。然而，有几个重要的事情会使这变得可行：

(1) 你将首先按牌值降序对牌进行排序。这使得找到顺子（按顺序排列的牌）变得容易得多，并且你将把“N张相同的牌”组合在一起。
(2) 找到“N张相同的牌”的代码对于4张、3张和2张基本相同（所以我们可以将其抽象成一个函数...）。
(3) 葫芦和两对实际上只是三条和一对（所以我们已经有了那个代码...）再加上另一对（所以我们可以只写一个函数来找到次要的一对）。
(4) 我们将做两个简化的假设：
       - 如果有同花，它将只出现在最多一种花色中。
         （例如，你不会有 As Ah Kh Qs 8s 7h 4s 3s 3h 2h，这有两种不同的同花）。
       - 如果有一个顶级顺子，那么不会同时有一个低位顺子。
     （这两个假设适用于所有主要的扑克变体）

如果你打开 `eval.c`，你将需要编写以下函数：

 - `int card_ptr_comp(const void * vp1, const void * vp2)` 
    你想要按牌值对手牌进行排序，所以你需要一个比较函数来传递给快速排序。
    快速排序会按升序排序，但你想要降序，所以你会想要返回：
       如果 card1 > card2，返回小于 0 的值
       如果 card1 == card2，返回 0
       如果 card1 < card2，返回大于 0 的值
    如果两张牌的值相同，按照 `enum suit_t` 的顺序比较它们的花色：
       梅花 < 方块 < 红心 < 黑桃
    注意 vp1 和 vp2 被作为 const void * 传递，因为这是 qsort 要求的类型。
    在使用它们之前，它们应该分别被赋值给类型为 `const card_t * const * cp1` 的变量（这很像你阅读中的字符串数组排序）。
    要了解更多关于使用 C 语言库函数 qsort 的信息，我们建议回顾课程阅读中的“排序函数”和“函数指针”课程，并查阅 “man qsort” 来阅读关于比较函数的信息。

 - `suit_t flush_suit(deck_t * hand);`
   这个函数查看手牌并确定是否存在同花（至少5张同一花色的牌）。
   如果存在，它返回构成同花的牌的花色。如果不存在，它返回 `NUM_SUITS`。
   例如：
    给定 Ks Qs 0s 9h 8s 7s，它会返回 SPADES。
    给定 Kd Qd 0s 9h 8c 7c，它会返回 `NUM_SUITS`。

 - `unsigned get_largest_element(unsigned * arr, size_t n);`
   这个函数返回一个无符号整数数组中的最大元素。这应该是你从视频中熟悉的。

   在第四课程中（在你学会动态分配内存之后），你将编写 `get_match_counts`，
   它将构建一个数组，每张牌在手牌中都有一个元素。该数组将告诉你手牌中有多少张牌的值与相应的牌相同。然后你将使用 `get_largest_element` 来确定哪个是最好的“N张相同的牌”。

 - `size_t get_match_index(unsigned * match_counts, size_t n, unsigned n_of_akind);`
   这个函数返回数组（match_counts）中值为 n_of_akind 的索引。数组有 n 个元素。数组 match_counts 可能有多个值等于 n_of_akind。你应该返回值为 n_of_akind 的最低索引[这也保证它对应于最大值的牌，因为它们将被排序]。
   （一旦你确定了上面最好的 n_of_akind，你将使用它来定位手牌中的那组牌）。
    注意保证 n_of_akind 在 match_counts 中。如果不是，你应该中止，因为这是一个错误的证据。

 - `ssize_t find_secondary_pair(deck_t * hand, unsigned * match_counts, size_t match_idx);`
   当你有一副手牌包含三条或一对时，你会想要查看是否还有另一对，以使手牌成为葫芦或两对。这个函数接收手牌、之前的匹配计数，以及找到原始匹配（三条或一对）的索引。它应该找到满足以下条件的牌的索引：
     - 它的匹配计数大于 1 [所以至少有一对]
     - 该牌的值不同于 match_idx 处牌的值（所以它不是原始的三条/一对的一部分）
     - 它是满足前两个条件的最低索引（这将是那对牌的开始，以及除原始匹配外的最高值对）。
   如果找不到这样的索引，这个函数应该返回 -1。

 - `int is_straight_at(deck_t * hand, size_t index, suit_t fs)`
   这个函数应该确定在给定手牌的索引处（并且只在索引处）是否有顺子。如果 fs 是 `NUM_SUITS`，那么它应该寻找任何顺子。如果 fs 是其他值，则它应该寻找指定花色的同花顺。
    这个函数应该返回：
    -1 如果在该索引处找到了 Ace 低位顺子（并且该索引是 Ace）
     0 如果在该索引处没有找到顺子
     1 如果在该索引处找到了
在编写这个函数时，你可以假设手牌是按牌值排序的：牌的值将以降序出现（A K Q ... 4 3 2）。

这个函数有两个使其复杂的地方（可能是这个任务中最棘手的函数）：
1. Ace低位顺子。Ace低位顺子会以Ace首先出现在手牌中，然后可能是一些其他的牌，然后是5 4 3 2。例如，你可能会有As Ks Qc 5s 4c 3d 2c。
2. 你可能会有多张相同值的牌，但仍然有顺子：As Ac Ks Kc Qh Jh 0d，即使A K Q没有在我们排序的顺序中相邻出现。

提示：我通过编写两个辅助函数来简化这个问题：
- `int is_n_length_straight_at(deck_t * hand, size_t index, suit_t fs, int n)`；
- `int is_ace_low_straight_at(deck_t * hand, size_t index, suit_t fs)`。

第二个函数让我可以处理Ace低位顺子的复杂性。然而，在这样做的过程中，我意识到在Ace低位顺子的辅助函数和原始函数之间会有很多代码重复（对于Ace低位，你想找到一个5，然后是长度为4的顺子：5, 4, 3, 2）。这个认识使我将大部分代码提取到`is_n_length_straight_at`中，这样我就可以用n=4来搜索Ace低位顺子的5,4,3,2部分。

- `hand_eval_t build_hand_from_match(deck_t * hand, unsigned n, hand_ranking_t what, size_t idx)`；
  现在你已经编写了一系列函数来确定手牌的排名。是时候构建一个`hand_eval_t`（见eval.h），它包含排名和用于它的5张牌。这个辅助函数将处理“n张相同的牌”的情况。它应该创建`hand_eval_t`并将其排名设置为传入的“what”值。然后它应该从手牌中复制“n”张牌，从“idx”开始，到`hand_eval_t`的“cards”数组的前“n”个元素中。`hand_eval_t`中的cards字段声明为：
  ```
  card_t * cards[5]
  ```
  这是一个指针数组，每个指针指向一个`card_t`。在你开始编写代码之前，画一个图确保你知道如何命名每个`card_t`“盒子”。

  你的函数应该用手牌中未在“n张相同的牌”中的最高值牌填充“cards”数组的其余部分。

  例如，给定这副手牌：
  ```
  As Kc Kh Kd Qc 8s 5d
  ```
  手牌有3个国王，As和Qc将打破平局。注意这里n=3，what=THREE_OF_A_KIND，idx=1。所以`hand_eval_t`中的cards数组应该有：

  ```
  Kc Kh Kd As Qc
  ```

  注意what也可能是FULL_HOUSE或TWO_PAIR，因为这个函数将用于准备这些评估的第一部分（然后其他代码将稍后修复手牌中的其他对牌）。

- `int compare_hands(deck_t * hand1, deck_t * hand2)`

  这是整个事情的目标：给定两副手牌，确定哪一副赢了（或者是否打成了平手）。你编写的所有东西都将组合在一起使这成为可能。

  我们为你提供了`hand_eval_t evaluate_hand(deck_t * hand)`；因为它涉及到一些你直到第四课程才会学到的内容。它也不是特别有趣：它主要是调用你上面写的函数，并且有很多if语句来处理扑克的规则。

  `evaluate_hand`的重要部分是它假设传入手牌的牌已经排序，并且它为传入的手牌返回一个`hand_eval_t`。

  这意味着要实现`compare_hands`，你应该：

  (a) 使用qsort对每副手牌的牌进行排序，并使用你之前写的`card_ptr_comp`。
  (b) 对每副手牌调用`evaluate_hand`，这将为每副手牌提供一个`hand_eval_t`。
  (c) 检查`hand_eval_t`中的排名是否相同或不同。如果它们不同，你可以直接使用排名来确定赢家。
  (d) 如果它们相同，那么你需要查看每个`hand_eval_t`的`cards`数组中的值来打破平手。我们构建`hand_eval_t`的`cards`数组的方式意味着牌已经按照从最重要（索引0）到最不重要（索引4）的顺序排列。你可以在数组中的值上进行字典顺序比较。（就像比较字符串一样，但你是在比较牌的值——如果元素0是不同的，使用那个差异来确定你的答案。如果元素0相同，看元素1，依此类推）。

  注意`compare_hands`应该返回一个正数，如果手牌1更好，0如果手牌打成平手，和一个负数如果手牌2更好。

你还会注意到在 `eval.c` 底部我们提供了一些函数。你不需要对这些做任何事情——我们为你写了它们，以保持代码量可管理。

--------------
那确实是很多代码！你一直在编译和测试，对吧？我们当然希望如此 :)

然而，为了帮助你更多地测试，我们为你提供了一些测试基础设施。

如果你执行

make 

你将编译你从第二课程中熟悉的 `test-eval` 程序。这个程序的行为与第二课程中的完全相同。作为提醒，它期望输入的每一行看起来像：

hand1 ; hand2

其中一副手牌看起来像 `print_hand` 输出的东西。所以一个有效的输入可能是

Kc Ac Jh 8s 9c 2s ; Ah Kh 0s 7c 7h 3c

对于输入中的每一行，测试程序将告诉你：
 - 你的函数评估它时的结果（是否有顺子，是否有同花等）。
 - 每副手牌的 `evaluate_hand` 返回了什么 `hand_eval_t`。
 - 根据 `compare_hands`，哪副手牌赢了（或者是否打成了平手）。

你有所有那些从第二课程中的测试用例可以使用！

因为你有一个对象文件 `test-eval.o` 而不是源文件 `test-eval.c`，你可能需要以不同于你习惯的方式使用调试器。对于这个测试程序，我们建议在 emacs 中运行 gdb，然后首先，指定命令行参数（在这个例子中，是一个包含你测试的文件名）

set args tests.txt

然后你会想在你写的代码中设置一个断点（因为你看不到 `test-eval.c`，也就是 main 函数在哪里，所以无法逐步执行）。例如，如果你刚写了函数 `is_straight_at`，并且它的表现不符合你的预期，你可以做

break is_straight_at

并且 gdb 将在程序调用那个函数时暂停执行。然后你可以使用命令 "run" 而不是 "start"，因为你不需要在 main 的开始处暂停执行。也请回顾一下 "continue" 命令，你可以从调试课程中复习。

像往常一样，当你完成后，使用 "grade" 命令。
当你通过这个命令时，恭喜你！你已经完成了第三课程，准备进入第四课程了 :)

// 做测试的方法
测试用例的文本名称例如tests.txt。每一行应该包含两副手牌，测试案例的格式如下：
Kc Ac Jh 8s 9c 2s ; Ah Kh 0s 7c 7h 3c

但是系统给的源程序tests.txt是一个空文件，并链接到其他目录，如下
$ ls -l tests.txt
lrwxrwxrwx 1 student users 27 Jun 21 17:38 tests.txt -> ../c2prj2_testing/tests.txt
由于c2prj1_testing目录位于其他服务器，如果不知道如何访问，可以在本地重新建一个文件tests1.txt，写测试案例。
