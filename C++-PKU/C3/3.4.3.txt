
// this solution pass the examination of coursera. 


class Array2
{
private:
    int **ptr;  // Double pointer for dynamic 2D array
    int row;    // Number of rows
    int col;    // Number of columns
public:
    Array2(int i = 0, int j = 0);  // Constructor with default parameters
    Array2(Array2 &a);             // Copy constructor
    ~Array2();                     // Destructor
    Array2& operator=(const Array2 &a);  // Assignment operator
    int& operator()(int i, int j) { return ptr[i][j]; }  // Overloaded parentheses operator
    int* operator[](int i) { return ptr[i]; }           // Overloaded square brackets operator
};

// Constructor with parameters for initializing and allocating memory for the 2D array
Array2::Array2(int i, int j)
{
    if (i == 0 || j == 0)
    {
        ptr = NULL;  // If rows or columns are zero, set pointer to NULL
    }
    else
    {
        row = i;  // Initialize number of rows
        col = j;  // Initialize number of columns
        ptr = new int*[row];  // Allocate memory for rows
        for (int k = 0; k < row; k++)
        {
            ptr[k] = new int[col];  // Allocate memory for columns in each row
        }
    }
}

// Copy constructor for deep copying the 2D array
Array2::Array2(Array2 &a)
{
    if (!a.ptr)
    {
        ptr = NULL;  // If the source object's pointer is NULL, set this object's pointer to NULL
        row = 0;
        col = 0;
        return;
    }
    else
    {
        ptr = new int*[a.row];  // Allocate memory for rows
        for (int k = 0; k < a.row; k++)
        {
            ptr[k] = new int[a.col];  // Allocate memory for columns in each row
            memcpy(ptr[k], a.ptr[k], sizeof(int) * a.col);  // Copy the data
        }
        row = a.row;
        col = a.col;
    }
}

// Destructor for freeing the allocated memory
Array2::~Array2()
{
    if (ptr)
    {
        for (int i = 0; i < row; i++)
        {
            delete[] ptr[i];  // Free memory for each row
        }
        delete[] ptr;  // Free memory for the array of row pointers
    }
}

// Assignment operator for deep copying the 2D array and freeing old memory
Array2& Array2::operator=(const Array2 &a)
{
    if (ptr == a.ptr)
    {
        return *this;  // Prevent self-assignment
    }
    if (a.ptr == NULL)
    {
        if (ptr)
        {
            for (int i = 0; i < row; i++)
            {
                delete[] ptr[i];  // Free old memory for each row
            }
            delete[] ptr;  // Free old memory for the array of row pointers
        }
        ptr = NULL;  // Set pointer to NULL
        row = 0;
        col = 0;
        return *this;  // Return the current object
    }
    if (row < a.row || col < a.col)
    {
        if (ptr)
        {
            for (int i = 0; i < row; i++)
            {
                delete[] ptr[i];  // Free old memory for each row
            }
            delete[] ptr;  // Free old memory for the array of row pointers
        }
        ptr = new int*[a.row];  // Allocate new memory for rows
        for (int k = 0; k < a.row; k++)
        {
            ptr[k] = new int[a.col];  // Allocate new memory for columns in each row
            memcpy(ptr[k], a.ptr[k], sizeof(int) * a.col);  // Copy the data
        }
        row = a.row;
        col = a.col;
        return *this;  // Return the current object
    }
}
